#Just to keep track of all the changes made to this version of platon and how to properly use this version.
CHIMA:
1) Split the plotting and the running of the retrieval in two separate codes (PlatonPlot.py and retriever_multinest.py), because Hydra can't plot inside a submitted job for some reason.

2)Added an input.py file for both the plotting and retrieval scripts (Plt_Retriv_Input.py and retrieval_input.py). The input files are used to specify the parameters wanted for the retrieval. i.e the initial guesses of the retrieval, the bounds of the retrieval, plotting and formatting request, etc. The idea is that one doesn't have to edit the plotting or retriever code itself. This is the same idea which Ian used for his edits to Nestor's exoretrieval so should look familiar if you've used that. 

3)Created 'Dats' folder, which contains all the .dat files of the data that you want the retrieval to fit for. The .dat files are of the exact same structure that Nestor's exoretrieval takes: Wav_low(Ang),Wav_up,Depth(ppm),Err_up,Err_dwn,Insturment(name),Offset(Yes/No)

4)Added support for arbitrary amount of offsets. To use properly, 1st must specify number of instruments your full dataset has (including ones you don't want to be offset!) with the variable 'InstNum' in the retrieval_input script. Then you add three variables for each instrument: Offset#, Offset#_Rng, and Offset#_Wavs where # is the numbered order in which that instrument is provided in the .dat file (starting at 1). Offset# = initial offset guess. Offset#_Rng = offset range, where this is relative to the mean of the depth for that instrument. So if Offset#_Rng = .5 there will be a uniform prior with lower bound -Meandepth*0.5 and upper bound Meandepth*0.5. Offset#_Wav = the wavelength range of the instrument, the code isn't compatible with two separate instruments that have overlapping wavelengths. If you don't want Offsets for that specific instrument set Offset# = 0 and Offset#_Rng = None. If you want no offsets at all set InstNum = None

5)In the platon version that James edited it pickled much of the outputs. I removed those pickling inside the retrieval scripts because it drastically increased the run time of the code (I tested it and it was about ~6 times slower), because it'd have to reopen a pickle file after every samples iteration. However, all that data is now saved in transit_depth_calculator.compute_depths()'s info_dict, so can still be accessed. 

6)The way PlatonPlot.py works is that it uses the results of the retrieval to resample from the probability distribution the Nested sampling found via the dynesty.utils.resample_equal() function. Then your resampled parameters are used to recompute values such as the transit depth and everything in the .compute_depths()'s info_dict. This is then used to produce the median fit and 1sig confidence bounds of the transit depth. This could also be used to plot the median fit and 1sig confidence bounds of other things such as absorption coefficients, T-P profiles, atmospheric abundances, etc. which is saved in results_full_output.pkl. This was found to be much faster of a run time rather than saving the initial MultiNest samples as it's sampling. PlatonPlot.py also saves the corner plots of MultiNest's results.

7)The way the retriever_multinest.py data storage is set up, is there will be a subdirectory created based off the Target name specified in retrieval_input.py, then another subdirectory named after what all is being fit for. It saves the 2 retriever.run_multinest results (results & fit info), an INFO.txt file with details about you specific run, and the .dat file of the data you used. When you run PlatonPlot.py for the 1st time it saves some .pkl files needed to do the resampling properly a .dat file with the fitted transmission spectrum median and 1sig confidence bounds.



TODO:
1)Have corner plot a vertical line that represents the best fit (different from the mean), with a different color from the confidence intervals

2)Kill all usage of exec()

3)Figure out how to implement error_multiple fit results to final plot
